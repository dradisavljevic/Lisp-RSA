; Implementation of the few RSA based functions for a project
; Not recommended that they are used for serious encryption as they still need improvement

;Function that encrypts message through RSA for random numbers
(defun rsa-blackbox-encrypt-kzi (message)
(defvar primelist)
(defvar q)
(defvar p)
(defvar n)
(defvar totient)
(defvar coprimelist)
(defvar e)
(defvar d)
(defvar ecmessage)
(defvar rsabyte)
(setf ecmessage '(nil))
(setf message (ironclad:ascii-string-to-byte-array message))
(setf message (coerce message 'list))
(setf primelist (primes-between 1 1000))
(setf p (nth (random (length primelist)) primelist))
(setf q (nth (random (length primelist)) primelist))
(setf n (* p q))
(setf totient (lcm (- p 1) (- q 1)))
(setf coprimelist (coprimes-list totient))
(setf e (nth (random (length coprimelist)) coprimelist))
(setf d (modular-multiplicative-inverse e totient))
(loop for mbyte in message
 do (progn (setf rsabyte (rem (expt mbyte e) n)) (setf ecmessage (cons rsabyte ecmessage)))
)
 (setf ecmessage (remove nil ecmessage))
 (setf ecmessage (reverse ecmessage))
 (setf ecmessage (mapcar #'code-char ecmessage))
 (setf ecmessage (coerce ecmessage 'string))
 (return-from rsa-public-kzi ecmessage) 
)

;Demonstration used to prove that random numbers indeed ad up to functional RSA algorithm
(defun rsa-blackbox-demo-kzi (message)
(defvar primelist)
(defvar q)
(defvar p)
(defvar n)
(defvar totient)
(defvar coprimelist)
(defvar e)
(defvar d)
(defvar ecmessage)
(defvar dcmessage)
(defvar rsabyte)
(defvar messageholder)
(setf ecmessage '(nil))
(setf dcmessage '(nil))
(setf message (ironclad:ascii-string-to-byte-array message))
(setf message (coerce message 'list))
(setf primelist (primes-between 1 1000))
(setf p (nth (random (length primelist)) primelist))
(setf q (nth (random (length primelist)) primelist))
(setf n (* p q))
(setf totient (lcm (- p 1) (- q 1)))
(setf coprimelist (coprimes-list totient))
(setf e (nth (random (length coprimelist)) coprimelist))
(setf d (modular-multiplicative-inverse e totient))
(loop for mbyte in message
 do (progn (setf rsabyte (rem (expt mbyte e) n)) (setf ecmessage (cons rsabyte ecmessage)))
)
 (setf ecmessage (remove nil ecmessage))
 (setf ecmessage (reverse ecmessage))
 (setf messageholder ecmessage)
 (setf ecmessage (mapcar #'code-char ecmessage))
 (setf ecmessage (coerce ecmessage 'string))
 (print ecmessage)
(loop for mbyte in messageholder
 do (progn (setf rsabyte (rem (expt mbyte d) n)) (setf dcmessage (cons rsabyte dcmessage)))
)
 (setf dcmessage (remove nil dcmessage))
 (setf dcmessage (reverse dcmessage))
 (setf dcmessage (mapcar #'code-char dcmessage))
 (setf dcmessage (coerce dcmessage 'string))
 (print dcmessage)
)

;Function that encypts given message through RSA with random parameters
;Upper bound for prime numbers is forwarded as a parameter
;bound larger than 10000 can lead to slow performance
(defun rsa-blackbox-encrypt-unlimited-kzi (message bound)
(defvar primelist)
(defvar q)
(defvar p)
(defvar n)
(defvar totient)
(defvar coprimelist)
(defvar e)
(defvar d)
(defvar ecmessage)
(defvar rsabyte)
(setf ecmessage '(nil))
(setf message (ironclad:ascii-string-to-byte-array message))
(setf message (coerce message 'list))
(setf primelist (primes-between 1 bound))
(setf p (nth (random (length primelist)) primelist))
(setf q (nth (random (length primelist)) primelist))
(setf n (* p q))
(setf totient (lcm (- p 1) (- q 1)))
(setf coprimelist (coprimes-list totient))
(setf e (nth (random (length coprimelist)) coprimelist))
(setf d (modular-multiplicative-inverse e totient))
(loop for mbyte in message
 do (progn (setf rsabyte (rem (expt mbyte e) n)) (setf ecmessage (cons rsabyte ecmessage)))
)
 (setf ecmessage (remove nil ecmessage))
 (setf ecmessage (reverse ecmessage))
 (setf ecmessage (mapcar #'code-char ecmessage))
 (setf ecmessage (coerce ecmessage 'string))
 (return-from rsa-blackbox-encrypt-unlimited-kzi ecmessage) 
)


;RSA encryption for given parameters on an ascii string message
(defun rsa-encrypt-kzi (message p q e)
(if (isprime p) 
(if (isprime q) 
(if (coprime (* p q) e) (progn
	(defvar primelist)
	(defvar n)
	(defvar totient)
	(defvar coprimelist)
	(defvar d)
	(defvar ecmessage)
	(defvar rsabyte)
	(setf ecmessage '(nil))
	(setf message (string-to-bytes message))
	(setf n (* p q))
	(setf totient (lcm (- p 1) (- q 1)))
	(setf d (modular-multiplicative-inverse e totient))
	(loop for mbyte in message
	 do (progn (setf rsabyte (rem (expt mbyte e) n)) (setf ecmessage (cons rsabyte ecmessage)))
	)
	 (setf ecmessage (remove nil ecmessage))
	 (setf ecmessage (reverse ecmessage))
	 (setf ecmessage (mapcar #'code-char ecmessage))
	 (setf ecmessage (coerce ecmessage 'string))
	 (return-from rsa-encrypt-kzi ecmessage)
) (return-from rsa-encrypt-kzi "Value for e is not a coprime of totient (p*q)")
) (return-from rsa-encrypt-kzi "Value for q is not a prime number")
) (return-from rsa-encrypt-kzi "Value for p is not a prime number")
))

;RSA decryption for given parameters on a byte array
(defun rsa-decrypt-kzi (bytes p q e)
(if (isprime p) 
(if (isprime q) 
(if (coprime (* p q) e) (progn
	(defvar primelist)
	(defvar n)
	(defvar totient)
	(defvar coprimelist)
	(defvar d)
	(defvar dcmessage)
	(defvar rsabyte)
	(setf dcmessage '(nil))
	(setf bytes (string-to-bytes bytes))
	(setf n (* p q))
	(setf totient (lcm (- p 1) (- q 1)))
	(setf d (modular-multiplicative-inverse e totient))
	(loop for mbyte in bytes
	 do (progn (setf rsabyte (rem (expt mbyte d) n)) (setf dcmessage (cons rsabyte dcmessage)))
	)
	 (setf dcmessage (remove nil dcmessage))
	 (setf dcmessage (reverse dcmessage))
	 (setf dcmessage (mapcar #'code-char dcmessage))
	 (setf dcmessage (coerce dcmessage 'string))
	 (return-from rsa-decrypt-kzi dcmessage)
) (return-from rsa-decrypt-kzi "Value for e is not a coprime of totient (p*q)")
) (return-from rsa-decrypt-kzi "Value for q is not a prime number")
) (return-from rsa-decrypt-kzi "Value for p is not a prime number")
))

